# 图的连通性

## 重连通图

**双/重连通性(biconnectivity)**：一个<u>连通的无向图</u>中的<u>任一顶点</u>删除后，剩下的图<u>仍然连通</u>，那么这样的无向连通图称为是**双连通的(biconnected)**。

如果图不是双连通的，那么，将其删除后图不再连通的那些顶点叫做**割点/关节点(articulation point)**。

一个没有割点的连通图称为**重连通图(biconnected graph)**。

若在一个连通图上至少删去k个顶点才能破坏该图的连通性，则称此图的**连通度(biconnected degree)**为k。

> 关节点和重连通图在实际中较多应用。显然，一个表示通信网络的图的连通度越高，其系统越可靠，无论是哪一个站点出现故障或遭到外界破坏，都不影响系统的正常工作；又如，一个航空网若是重连通的，则当某条航线因天气等某种原因关闭时，旅客仍可从别的航线绕道而行；再如，若将大规模的集成电路的关键线路设计成重连通的话，则在某些元件失效的情况下，整个片子的功能不受影响，反之，在战争中，若要摧毁敌方的运输线，仅需破坏其运输网中的关节点即可。
>
> 双连通图的应用：
>
> + 计算机网络：很多个计算机连接形成的网络中，任意一台计算机出故障，可以保证其余计算机间的联络不中断
> + 公交运输系统：任意一个公交站被破坏，乘客可以选择其他的线路乘车
>

### Tarjan算法

暴力方法（直接依据割点的定义）：

+ 依次删除每一个顶点v
+ 用DFS或BFS判断图是否仍然连通
+ 再把顶点v重新加入到图中

深度优先搜索给出了一种找出连通图中所有割点的线性时间算法。

Robert Tarjan发明了基于DFS的一系列算法，用于求连通分量、割点、桥等，称为**Tarjan算法**。

**深度优先遍历生成树(depth-first spanning tree)**：用DFS对图进行遍历时，按照遍历次序的不同，我们可以得到一棵DFS生成树。

假设DFS中我们从顶点U访问到了顶点V（此时顶点V还未被访问过），那么我们称顶点U为顶点V的**父顶点**，V为U的**孩子顶点**。在顶点U之前被访问过的顶点，我们就称之为U的**祖先顶点**。

显然，如果顶点U的所有孩子顶点可以不通过父顶点U而访问到U的祖先顶点，那么说明此时去掉顶点U不影响图的连通性，U就不是割点。相反，如果顶点U至少存在一个孩子顶点，必须通过父顶点U才能访问到U的祖先顶点，那么去掉顶点U后，顶点U的祖先顶点和孩子顶点就不连通了，说明U是一个割点。

+ **树边(tree edge)**：在DFS的过程中访问未访问的节点所经过的边。
+ **回边(back edge)**：在DFS的过程中遇到已访问节点时所经过的边。通过回边可以从一个点返回到之前访问过的顶点。

---

+ 割点的判定方法：

  + 对于根节点v，若v有两棵或两棵以上的子树，则根节点v是割点
  + 对于叶子节点v，它一定不是割点
  + 对于中间节点v（既不是叶子节点也不是根节点），若其子树的节点均没有指向v的祖先节点的回边，说明删除v之后，v的祖先节点与v的后代节点不再连通，则节点v是割点

  当(u,v)为树边且`low[v] >= dfn[u]`时，节点u才为割点。该式子的含义：以节点v为根的子树通过回边所能追溯到最早的祖先节点要么为v要么为u

+ 桥的判定方法：
  
  + 若low[v] > dfn[u]，则说明(v, u)是桥

---

对于根节点，显然很好处理，我们只要计算它子树的数量；但是对于非叶非根节点，我们需要判断它的后代与祖先之间是否存在回边。



Tarjan算法维护两个数组 dfn 和 low：

+ dfn[v]：记录顶点v在DFS过程中被访问的次序（时间戳）。（或者说节点在DFS搜索树中的深度）

  + dfn数组的下标表示顶点的编号，数组中的值表示该顶点在DFS中的遍历顺序(或者说时间戳)，每访问到一个未访问过的顶点，访问顺序的值（时间戳）就增加1。
    **子顶点的dfn值一定比父顶点的dfn值大**（但不一定恰好大1，比如父顶点有两个或两个以上分支的情况）。
    **<u>在访问一个顶点后，它的dfn的值就确定下来了，不会再改变。</u>**

+ low[v]：记录节点v或v的子树通过非父子边追溯到最早的（即DFS的次序号最小）祖先顶点。
  
  + low数组的下标表示顶点的编号，数组中的值表示DFS中该顶点:star:**<u>不通过父顶点</u>**（但能通过子顶点）能访问到的祖先顶点中最小的顺序值（或者说时间戳）。
  
    每个顶点初始的low值和dfn值应该一样，在DFS中，我们根据情况不断更新low的值。
  
  $$
  \begin{equation}
  low[v]
  \begin{cases}
  min\{low[u], \ low[v]\}& \text{(u,v)为树边} \\
  min\{low[u], \ dfn[v]\}& \text{(u,v)为回边且v不为u的父亲节点}
  \end{cases}
  \end{equation}
  $$
  

初始时，dfn[v]和low[v]的值都被初始化为v。

---

