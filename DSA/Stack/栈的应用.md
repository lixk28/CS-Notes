# 栈的应用

## 括号匹配

Question：给定一个表达式 E，包含各种字符，包括字母、数字、标点、空格和括号 () [] {} 等。判断这个表达式中的括号是否匹配。括号匹配指的是表达式中的括号左右对应且类型相同。

~~~C++
int isMatch(string exp);
~~~

错误类型包括3种类型，分别根据错误类型返回1-3，如果括号匹配则返回0： 

+ 类型1：左右括号不匹配，如`"(]", "(((]))))", "((}","{x=a[0)*(b+c); y=b}"` 
+ 类型2：发现有左括号不存在与之匹配的右括号，如`"(", "(([]", "()([()"` 
+ 类型3：发现有右括号不存在与之匹配的左括号，如`")", "())","(())]()"`

---

:star:Algorithm：

1. 遍历输入的表达式

   + 如果遇到左括号，则该左括号入栈
   + 如果遇到右括号，判断栈是否为空
     + 若栈空，则说明有右括号而不存在与之匹配的左括号，返回错误类型3
     + 若栈不空，判断栈顶的括号是否与当前括号匹配，如果匹配，则栈顶出栈，继续遍历表达式，否则括号不匹配，返回错误类型1

2. 遍历结束后，判断栈是否为空

   + 若栈空，则说明括号匹配，返回正确类型0

   + 若栈不空，则说明有左括号而不存在与之匹配的右括号，返回错误类型2

---

Code:

注意用getline(cin, exp)读取一行表达式

~~~C++
bool isPair(char c1, char c2)	//用于判断两个括号是否匹配
{
    if(c1 == '(' && c2 == ')')  
        return true;
    else if(c1 == '[' && c2 == ']')
        return true;
    else if(c1 == '{' && c2 == '}')
        return true;
    else 
        return false;
}

int isMatch(string exp)
{
    stack<char> s;
    for(int i = 0; i < exp.length(); i++)
    {
        if(exp[i] == '(' || exp[i] == '[' || exp[i] == '{')		//遇到左括号
            s.push(exp[i]);
        else if(exp[i] == ')' || exp[i] == ']' || exp[i] == '}')	//遇到右括号
        {
            if(!s.empty())
            {
                if(isPair(s.top(), exp[i]))	//判断两个括号是否匹配
                    s.pop();
                else
                    return 1;
            }
            else
                return 3;
        }
    }
    if(!s.empty())
        return 2;
    else
        return 0;
}
~~~

---

## 表达式求值

Question：给定一个表达式，包括 +、-、*、/、数字和圆括号 () 的合法算术表达式，计算表达式的运算结果

~~~C++
string IntoPost(string inexp);
double Calculator(string postexp);
~~~

表达式的形式：

+ **前缀表达式（prefix）**：运算符位于操作数的前面
+ **中缀表达式（infix）**：运算符位于两个操作数中间的表达式，是我们日常生活中最常用的表达式形式
+ **后缀表达式（suffix/postfix)）/ 逆波兰表达式**：运算符在操作数的后面，<u>在后缀表达式中，已经考虑了运算符的优先级，没有括号，只有操作数和运算符，且越靠前的运算符越优先执行</u>

eg：中缀：(1 + 2) * 3 + 5

​		后缀：1 2 + * 3 5 +

---

**:star:中缀表达式转换为后缀表达式的算法**

在将一各中缀表达式转换成后缀表达式时，**<u>操作数之间的相对次序是不变的</u>**，但运算符的相对次序可能不同，同时还要去除括号。

Algorithm：

+ 如果遇到操作数，直接存放到后缀表达式中
+ 如果遇到运算符
  + 如果运算符栈为空，直接进栈
  + 如果运算符栈不空
    + 如果运算符栈栈顶是左括号，则将该运算进栈
    + 如果该运算符优先级高于栈顶运算符优先级，则将该运算符进栈
    + 如果该运算符优先级低于栈顶运算符优先级，则依次出栈，并将出栈的运算符存入后缀表达式中，直到栈顶运算符优先级小于该运算符的优先级为止，然后将该运算符进栈
+ 如果遇到括号
  + 如果是左括号，直接进栈
  + 如果是右括号，则依次出栈，并将出栈的运算符存入后缀表达式中，直到栈顶元素为左括号，再将左括号出栈

---

伪代码：

postexp表示后缀表达式，是一个string

:rocket::star::rocket:

~~~C++
while(c = exp[i], i < exp.length)
{
    c为数字: 将c存放到postexp中，并在c后面添加一个'#'，表示数字串的结束
    c为左括号: 将左括号进栈
    c为右括号: 栈顶运算符依次出栈并存放到postexp中，直到遇到左括号，再将左括号出栈
    c为运算符: 
    	if(栈空 或者 栈顶为左括号 或者 c的优先级高于栈顶运算符优先级)
            直接将c进栈
        else
            栈顶运算符依次出栈并存放到postexp中，直到c的优先级高于栈顶运算符，然后将c进栈
            
}
将栈中剩余的运算符依次出栈并存放到postexp中
~~~

---

代码：

~~~C++
string IntoPost(string inexp)


~~~

---

**:star:后缀表达式求值的算法**

从左到右遍历后缀表达式postfix：

+ 如果遇到操作数，将操作数进栈
+ 如果遇到运算符，从栈中连续出栈两个操作数 a 和 b，计算 a op b 的值，将计算结果进栈

遍历结束后，栈顶元素就是表达式的计算结果

---

代码：

~~~C++
double Calculator(string postexp)
    
~~~

---







## 函数调用栈

## 迷宫问题

