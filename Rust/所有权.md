
**所有权(ownership)** 是Rust的核心功能之一。
Rust通过所有权系统管理内存，无需程序员亲自分配和释放内存，这保证了Rust的安全和高效。

所有权规则：
- Rust中的每一个值都有一个被称为其 **所有者(owner)** 的变量
- 值在任一时刻有且只有一个所有者
- 当所有者(变量)离开作用域，这个值将被丢弃

变量的作用域与C相同。

在Rust中，内存在拥有它的变量离开作用域后就自动被释放。

## String类型

String是字符串类型，被**分配在堆上**，能够存储在编译时未知大小的文本。

## 变量与数据交互的方式

### 移动

Rust永远不会自动创建数据的深拷贝。

Rust中 **移动(move)** 操作，使前一个变量无效。这样防止了 **二次释放(double free)** 的问题。

### 克隆

clone方法可以复制堆上的数据。

### 只在栈上的数据

如果一个类型拥有`Copy`trait，一个旧的变量在将其赋值给其他变量后仍然可用。

标量类型和包含的类型全都是`Copy`的元组，是`Copy`类型。

只在栈上的数据，拷贝它们是快速的，Rust对于栈上的数据采用直接拷贝的方式。
也就是说，内存分配在栈上的变量，与C基本相同。

## 所有权与函数
s
将值传递给函数在语义上与给变量赋值相似。
向函数传递值可能会移动或者复制，就像赋值语句一样。

## 返回值与作用域

返回值也可以转移所有权。

**变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。**
当持有堆中数据值的变量离开作用域时，其值将通过`drop`被清理掉，除非数据被移动为另一个变量所有。

我们可以使用元组来返回多个值。

## 引用和借用

我们向函数传递值时，可能会使值的所有权发生转移。
我们可以使用 **引用(reference)** 作为参数，这样不会获取值的所有权。

引用`&`允许使用值，**但不获取其所有权，默认不能修改引用指向的值**。获取引用作为函数参数称为 **借用(borrowing)** 。

**一个引用的作用域从声明的地方开始到最后一次使用为止。**

如果需要修改引用指向的值，可以创建可变引用，在`&`后加`mut`。
**但这要求引用指向的值是可修改的（即mut）。**

可变引用有个限制，**在特定作用域中的特定数据只能由一个可变引用。**这个限制的好处是可以让Rust在编译时就避免 **数据竞争(data race)**。数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和恢复。

数据竞争可能由3个行为造成：
- 两个或更多个指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问机制

在一个作用域中，可以同时拥有多个不可变引用，但不能同时拥有多个可变引用，或者多个不可变引用加可变引用（不可变引用不希望它指向的数据发生变化，尽管只能读取这些数据）。



## 悬垂引用

**悬垂引用(dangling reference)** 类似于悬垂指针，但Rust编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。换句话说，引用不会指向已经被释放的内存。

## Slice类型

slice类型也没有所有权。slice允许你引用集合中一段连续的元素序列，而不用引用整个集合。

使用`[begin_index..end_index]`指定的range创建一个slice。对于`..`的range语法，若从第一个索引开始，可以省略`begin_index`，若以最后一个索引结束，可以省略`end_index`。

字符串slice的类型声明写作`&str`，注意到`&String`是字符串引用类型。
















