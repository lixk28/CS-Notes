# 顺序读写数据文件

---

## 1. 向文件读写字符

### 1.1**用 fgetc 函数 (file get character) 从文件中读入单个字符**

fgetc函数原型：

~~~C
int fgetc(File *fp);
~~~

fgetc函数所在库：<stdio.h>

fgetc函数功能：从 fp 所指向的文件读取一个字符

​                          **fgetc函数读取的字符是<u>文件读写位置标记指向的字符</u>**

​						  **每访问完一个字节后，读写位置就指向下一个字节**

fgetc函数返回值：若读取成功，所读的字符会作为一个无符号字符读取，并被转换成为一个整型值

​                       	  若读到文件的结尾或者读取失败，返回文件结束标志EOF（-1）

fgetc函数参数：一个文件指针变量，指向需要读的文件

fgetc函数调用的一般方式为：

~~~C
FILE *fp;
fp = fopen(文件名，文件使用方式);
int ch; //注意要用int！！！用char可能会出问题
ch = fgetc(fp); //从指定的文件中读取字符，得到的字符赋给ch
~~~

---

### 1.2**用 fputc 函数（file put character) 向文件输出单个字符**

fputc函数原型：

~~~C
int fputc(int ch, FILE *fp);
~~~

fputc函数所在库：<stdio.h>

fputc函数功能：向 fp 所指向的文件写入一个字符

​						  **fputc函数写入的字符将<u>储存在文件读写位置标记指向的位置</u>**

​						  **每输入一个字符，读写位置就指向下一个字节**

fputc函数返回值：若写入成功，则返回写入字符的ASCII码值

​							 若写入失败，则返回文件结束标志EOF（-1）

fputc函数参数：

+ ch 是要被写入的字符，该字符以其对应的ASCII码值进行传递
+ fp 是指向文件的指针变量，标识的是要被写入字符的文件

fputc函数调用的一般方式

~~~C
FILE *fp;
fp = fopen(文件名，文件使用方式);
int ch;
fput(ch,fp); //向指定的文件输入一个字符
~~~

---

### 1.3**用 feof 函数检测文件结尾标志是否被读取过**

***EOF* (End Of Flie) 是在标准输入输出库<stdio.h>中定义的宏，EOF的值被定义为 -1**

在文本文件中，数据都是以字符的ASCII代码值的形式存放。**由于ASCII码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。**

文件的有效字符最后都有一个**文件尾标志**

当读完所有的字符后，文件读写位置标记就指向最后一个字符的后面，即指向文件尾标志

如果再执行读取操作，则会读出 -1**（并不是最后一个字符后面还存在一个字节，其中存放着 -1）**



feof函数原型：

~~~C
int feof(FILE *fp);
~~~

feof函数所在库：<stdio.h>

**feof函数功能：检测文件尾标志是否已经被读取过**

**feof函数返回值：若文件尾标志已经被读过，返回非零值（真），表示文件已结束**

​						    **若文件尾标志未被读过，返回 0（假）**

feof函数参数：一个文件指针变量，表示需要检测的文件

feof函数调用的一般形式：

~~~C
feof(fp); //检测fp指向的文件
~~~

feof函数常用于条件判断：

~~~C
while(!feof(fp)) //当未读写到文件尾时
~~~



**C系统已在<stdio.h>头文件中把 fputc 和 fgetc 定义为宏名 putc 和 getc**

~~~C
#define putc(ch,fp) fputc(ch,fp)
#define getc(fp) fgetc(fp)
~~~

​		**因此，在程序中用 putc 和 fputc 的作用是一样的，用 getc 和 fgetc的作用是一样的**

​		在使用上，可以把它们当成一样的函数来对待

---

## 2. 向文件读写字符串

### 2.1 用 fgets 函数（file get string）从文件读入字符串

**fgets函数原型：**

~~~C
char *fgets(char *str, int n, FILE *fp);
~~~

fgets函数所在库：<stdio.h>

**fgets函数功能：从 fp 指向的文件中读取一个长度为 n 的字符串（实际上只有 n-1 个有效字符），然后将其存放在字符数组中/字符指针变量指向的内存空间中**

fgets函数返回值：若读取成功，返回 str 的地址（首地址）

​							 若读取失败，返回 NULL

fgets函数参数：str 是预先定义好存放读取的字符串的字符数组名/字符指针变量名

​					   **n 是字符串的长度，但实际上只从 fp 所指向的文件中读入 n-1 个字符，然后在这段字符末尾加一个 '\0' 字					   符，再把这 n 个字符作为得到的字符串，将其存放到字符数组中**

​					 <u>**注意：如果在读完 n-1 个字符之前遇到 换行符 '\n' 或 文件结束符EOF，读取立刻结束，但将遇到的换行符 					 '\n' 也作为一个字符输入**</u>

​						fp 指向的是被读取的文件

fgets函数调用的一般方式：

~~~C
char str[MAX_SIZE];
FILE *fp = fopen("filename","the way of using file");
fgets(str, n, fp);
~~~

---

### 2.2 用 fputs 函数（file put string）向文件输出字符串

fputs函数原型：

~~~C
int fputs(char *str, FILE *fp);
~~~

fputs函数所在库：<stdio.h>

**fputs函数功能：将 str 所指向的字符串输出到 fp 所指向的文件中**

fputs函数返回值：若输出成功，返回值为 0

​							 若输出失败，返回值为 EOF(-1)

fputs函数参数：**str 是字符数组名/字符指针变量/字符串常量，指向一段储存着字符串的内存**

​						 fp 指向被输出的文件

fputs函数调用的一般形式：

~~~C
char str[] = {"string"};
FILE *fp = fopen("filename","the way of using file");
fputs(str, fp); //写字符数组名或字符指针变量

FILE*fp = fopen("filename","the way of using file");
fputs("string", fp); //直接写需要输出到文件的字符串
~~~

***注意***：**<u>在向文件输出字符串时，只输出字符串的有效字符，并不包括 '\0'</u>**

​			<u>**若要输出多个字符串，在每次输出一个字符串后，须手动添加一个换行符 '\n'，否则字符串连成一片，无法阅读**</u>

~~~C
for(i=0;i<n;i++)
{
    fputs(str[i],fp); //将二维字符数组str的行元素作为字符串输出到fp指向的文件中
    fputc('\n',fp); //添加换行符'\n'
}
~~~

---

## 3. 格式化读写文本文件

### 3.1 用 fscanf 和 fprintf 函数进行格式化读写

利用 printf 函数和 scanf 函数可以对**终端**进行格式化的输入输出

也可以对**文件**进行格式化输入输出，这就要用到 fprintf 函数和 fscanf 函数

fprintf、fscanf 与 printf、scanf 相似，都是**格式化读写函数**，它们**只有一点不同**：fprintf 和 fscanf 的读写对象不是终端而是文件

**fprintf 和 fscanf 函数的一般调用形式为：**

~~~C
fprintf(文件指针,格式化字符串,输出表列); 

fscanf(文件指针,格式化字符串,输入表列);

// 后面两个参数与printf相同，只是前面多了一个文件指针，表示向文件输出
~~~

***注意：***<u>**fscanf 与 scanf 相同，遇到空格符' ' 换行符'\n' 或 制表符 '\t' 则输入结束**</u>

所以如果从文件一次性读取多个数据，这多个数据一般是用逗号 ，分隔开的

---

### 3.2 指向标准文件的指针

stdio.h头文件把 3 个文件指针与 3 个标准文件相关联，在执行一个C程序时，会自动打开这 3 个标准文件

| 标准文件 |             文件指针              | 通常使用的设备 |
| :------: | :-------------------------------: | :------------: |
| 标准输入 |     **stdin**(standard input)     |      键盘      |
| 标准输出 |    **stdout**(standard output)    |     显示器     |
| 标准错误 | **stderr**(standard error output) |     显示器     |

<u>**这 3 个文件指针都是指向FILE的指针变量，都可以作为标准I/O函数的参数**</u>

**利用fgets、fputs替代gets、puts：**

~~~C
char str[length]={'\0'};

fgets(str,length,stdin); //从键盘读入字符串
//作用等价于gets(str)

fputs(str,stdout); //向显示器输出字符串
//作用等价于puts(str)
~~~

---

## 4. 二进制方式读写数据

在程序中不仅需要一次输入输出**一个数据**，而且常常需要一次输入输出**一组数据**

C语言允许用 fread 函数从文件中读入一个数据块，用 fwrite 函数向文件输出一个数据块，在读写时是以二进制形式进行

**fread 和 fwrite 函数的一般调用形式：**

~~~C
fread(buffer,size,count,fp);

fwrite(buffer,size,count,fp);
~~~

fread 和 fwrite 函数位于库 <stdio.h>

**fread 和 fwrite 函数的类型为 int**

**若函数执行成功，函数返回值为形参 count 的值，即读写的次数（数据项的个数）**

**若函数执行失败，函数返回 0**

其中 ：

**buffer 是一个地址**

>  对于 fread 来说，buffer是**用来存放从文件读入的数据的存储区的地址**（起始地址）

> 对于 fwrite 来说，buffer是**用来存放将要向文件输出的数据的存储区的地址**（起始地址）								

**一般来说，buffer 常是一个结构体数组某个元素的地址，结构体中的成员是每次输入的不同数据项，数组的长度是读写的次数**

**size 是每个数据项读写的字节数**（常用sizeof表示）

**count 是读写的数据项的个数（每个数据项的长度为size）**

**fp 是被读写文件的指针**

在打开文件时，<u>**指定用二进制方式打开**</u>（否则会得不到语气的结果），这样就可以用 fread 和 fwrite 函数读写任何类型的信息

**fread 和 fwrite 的一般用法：**

~~~C
fwrite(buf,sizeof(buf),1,fp); 
fwrite(buf,sizeof(buf),1,fp);
// 执行成功返回 1

//一般将 fwrite 或 fread 放在循环内 若读写的次数为n，则执行n次
for(i=0;i<n;i++)
{
    if(fwrite(buf,sizeof(buf),1,fp) != 1) //若返回值不为1，说明这次写入失败
        printf("File write error!\n");
}

for(i=0;i<n;i++)
{
    if(fread(buf,sizeof(buf),1,fp) != 1) //若返回值不为1，说明这次读入失败
        printf("File read error!\n");
}

// buf 一般是结构体数组中某个元素的地址
~~~

注意：不能直接利用 fread 函数直接从键盘读数据！

~~~C
fread(&array[i],sizeof(struct data_type),stdin);
// struct data_type是一个结构体类型
// array是一个struct data_type类型的结构体数组

//如果输入的多个数据项之间用空格间隔，语法上并不会出错
//但是空格会作为输入数据而不作为数据间的分隔符
~~~

---

## 5. 文件内容的覆盖与清空&文件使用方式辨析

### 5.1 文件内容的清空

**如果想要清空文件的内容，只需要以只读的方式打开文件，文件内容即被清空**

~~~C
if( (fp=fopen("file.dat","w")) == NULL) //也可以是 w+ 
{
    printf("Clear file error!\n");
    exit(0);
}
~~~

### 5.2 文件使用方式的深入剖析与比较

**(1)  r  w  a （只读模式/只写模式/追加模式）**

+ 用 r 方式打开文件：(1)若文件存在，打开文件，**读指针定位到文件头**，**<u>不清空文件内容</u>**

  ​								(2)若文件不存在，报错文件不存在

+ 用 w 方式打开文件：(1)若文件存在，打开文件，**写指针定位到文件头**，**<u>清空文件内容</u>**

  ​								 (2)若文件不存在，则创建一个以输入的文件名命名的新文件

+ 用 a 方式打开文件：(1)若文件存在，打开文件，**写指针定位到文件尾**，**<u>不清空文件内容</u>**

  ​								 (2)若文件不存在，报错文件不存在

**(2)  r+  w+  a+ （读写模式）**

+ 用 r+ 方式打开文件：(1)若文件存在，打开文件，**文件读写位置指针重新定位到文件头**，**<u>但不清空文件内容</u>**

  ​        						  (2)若文件不存在，报错文件不存在

+ 用 w+ 方式打开文件：(1)若文件存在，打开文件，**文件读写位置指针重新定位到文件头，<u>并清空文件内容</u>**

  ​								    (2)若文件不存在，则创建一个以输入的文件名命名的新文件 

+ 用 a+ 方式打开文件：(1)若文件存在，打开文件，**读指针定位到文件头，写指针定位到文件尾**，<u>**且不清空文件内容**</u>

  ​									P：可以从任意位置开始读，但是只能追加写数据，不能从任意位置写数据
  
  ​								   (2)若文件不存在，报错文件不存在
  
  <u>添加 + 代表在原模式的基础上增加功能，但仍以原功能为主</u>

r+ 可读可写，从头读取，覆盖内容；

w+ 边读边写；

a+ 可读可写，从头读取，追加内容；



