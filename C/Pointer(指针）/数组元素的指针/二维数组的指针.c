//***** 二维数组可以看成是 数组的数组 
//***** 即二维数组中的每一个元素都是一个一维数组
 
#include<stdio.h>

int main()
{
	int a[5][5]={{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15},{16,17,18,19,20},{21,22,23,24,25}};
	// a 是二维数组名，a有三个行元素，每个行元素是一个一维数组 
	// 数组名代表的是数组首元素的起始地址，那么 a 代表的是 首行(a[0]) 的起始地址 
	// a+i 就代表序号为i的行的起始地址
	// 如果a的地址为2000，那么a+1的值就应该是2000+4*4=2016,因为一行有四个整型数据
	char str1[3][6]={{'I'},{'a','m'},{'G','r','o','o','t'}};
	int i,j;
	for(i=0;i<3;i++)
	printf("%s ",*(str1+i));
	printf("\n"); 
	
	// a[i] 是一维数组名，把a[m][n]看成 (a[m])[n] 
	// 因此 a[i] 代表一维数组 a[i] 的起始地址 (即a[i][0]元素的地址) 
	// a[i]+j 就代表 i行j列 的元素的地址 
	char str2[2][6]={{'H','e','l','l','o'},{'W','o','r','l','d'}};
	for(i=0;i<2;i++)
	  for(j=0;j<6;j++)
	    printf("%c",*(str2[i]+j));
	printf("\n");
	
	// 下面是验证    
    printf("Please input two integers between 0 and 4:\n");
    scanf("%d %d",&i,&j);
	 
	printf("a = %d\n\n",a);
	
	printf("a[0] = %d\n",a[0]);
	printf("*(a+0) = %d\n",*(a+0));
	printf("*a = %d\n\n",*a);
	
	printf("a+i = %d\n",a+i);
	printf("&a[i] = %d\n\n",&a[i]);
	
	printf("a[i] = %d\n",a[i]);
	printf("*(a+i) = %d\n\n",*(a+i));
	
	printf("a[i]+j = %d\n",a[i]+j);
	printf("*(a+i)+j = %d\n",*(a+i)+j);
	printf("&a[i][j] = %d\n\n",&a[i][j]);
	
	printf("*(a[i]+j) = %d\n",*(a[i]+j));
	printf("*(*(a+i)+j) = %d\n",*(*(a+i)+j));
	printf("a[i][j] = %d\n\n",a[i][j]);
	
	// 注意：(a+i)[j] 是先做 a+i 的运算，再做变址运算符[]的运算 
	printf("(a+i)[j] = %d\n",((a+i)[j]));  // 输出的是 (a+i+j)行 的起始地址 
	printf("*((a+i)[j]) = %d\n",*((a+i)[j]));  // 输出的是 (a+i+j)行首元素 的值 
	
	// 于是对二维数组中的某一个元素a[i][j]
	// 实际上是做指针运算 对a[i]做变址[j]运算 
	// 计算a[i][j]在数组中的相对位置：i*m+j 
	//***** 数组即指针 *****//
	 
	return 0;
}
/***** Summary *****/
// Let: array a[m][n]  &a=A  sizeof(a[m][n])=B 
  
/*************************二  维  数  组  的  指  针***********************************/ 
//     表示形式                                含义                        值(地址)   //
//       &a                            二维数组起始地址的地址                 A       // (三级指针) 
//        a                         二维数组(a)的起始地址(a[0]的地址)         A       // (二级指针) 
//     a+i  &a[i]                 二维数组(a)第i个元素的地址(a[i]的地址)   A+i*n*B    // (二级指针) 
//   a[0]  *(a+0)/*a                      0行0列元素的地址                    A       // (一级指针) 
//   a[i]  *(a+i)  &a[i]          一维数组(a[i])的起始地址(a[i][0]地址)    A+i*n*B    // (一级指针) 
//  a[i]+j  *(a+i)+j  &a[i][j]              a[i][j]元素的地址            A+(i*n+j)*B  // (一级指针) 
// *(a[i]+j)  *(*(a+i)+j)  a[i][j]          a[i][j]元素的值               a[i][j]     // 
/**************************************************************************************/ 
// P：二维数组名实际上是一个二级指针 a = &(&a[0][0])  

// C语言中的地址信息包括 位置信息(内存编号) 和 它所指向的数据的类型信息
// 若定义 int *p=&a  则p的基类型是 int 
// 虽然 a+i 和 *(a+i) 的纯地址相同，但它们的基类型不同，即他们所指向的数据类型不同
// a+i 指向的是一维数组，*(a+i) 指向的是整型数据  

//***** 在指向行的指针前面加一个 *，就转换为指向列的指针 
// a+i >>> *(a+i)
// &a[i] >>> *&a[i] >>> a[i] 

// 注意:地址值相同 但指向的数据类型（基类型）不同！！！

// Let: int a[m][n]
//          地址值/值           基类型
//  &a         A            int (*)[m][n]   (指向二维数组) 
//  a          A            int (*)[n]      (指向一维数组) 
//  *a         A            int *           (指向一个整型数据) 
//  **a     a[0][0]         int             (整型数据) 
 
 



